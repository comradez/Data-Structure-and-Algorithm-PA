# PA2-2解题报告

## 使用的数据结构和算法

用Trie树来存储64位01序列。通过动态插入和删除来保证每个元件查询时树上存储的所有元件都是能与这个元件组合的元件。查询时，为了使得异或最大，对于每一位，只要存在一个元件与它自己在这一位不同的、就向着不同的方向走，否则向相同方向走。

因为对于相同的元件要输出最靠前的那个，采取从后向前插入的策略，每个叶子结点只需要记录最后一次插入时元件的编号，查询时得到的就是最靠前的那个。

注意到极限情况下所有元素都相等，这样第0个元素会查询到本身，这是题目不允许的。但是因为这种极限情况仅仅在能与0结合的所有元件都和第0个元件完全相同时出现，因此只需要在输出前检查0的查询值是否是0（如果是就改为1）即可。

## 遇到的问题和解决方案

最初没有想到反向插入的方法，在每个叶子结点里加了一个链表，于是MLE了。然后改掉了。

在处理删除的时候，在从树上删除掉一个节点后要将树上这个位置置为nullptr以备再次插入，但我一开始只用了Node*值传递，导致树上的对应位置会指向一个delete过的非法内存空间导致RE。改为Node**后问题解决。

## 时空复杂度估算

一共要经过n次查询、n次插入、n次删除，每次的时间复杂度都是O(length)，也就是常数较大的O(1)，因此总时间复杂度O(n)。

树上最多存在2k+3个元件，每个元件对应64个节点，因此最多为常数较大的O(k)空间。总空间复杂度不超过O(n)。