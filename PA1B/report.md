# 01.cpp

## 最严重错误类型

我的编译器(GCC 7.5.0)上最严重的错误类型是TLE。

## 出错原因

string的insert()和erase()最坏复杂度是O(string长度)，程序运行的最坏复杂度O(mn)约为10^12量级，因此会TLE。

## 测例构造思路

1. 初始序列达到最长

2. 尽可能地让insert()和erase()达到最坏，因此要尽可能多地在头部插入、头部消除

因此构造了这样一组测例，每次都从头部插入，尽可能地从头部删除，同时规模接近最大。

事实上可以通过构造如下数据来使得程序访问-1下标，但我没能成功实现RE：

```
AA
1
0 A
```


# 02.cpp(测例同01.cpp)

## 最严重错误类型

最严重的错误类型是TLE。

## 出错原因

string的insert()和erase()最坏复杂度是O(string长度)，程序运行的最坏复杂度O(mn)约为10^12量级，因此会TLE。

## 测例构造思路

1. 初始序列达到最长

2. 尽可能地让insert()和erase()达到最坏，因此要尽可能多地在头部插入、头部消除

因此构造了这样一组测例，每次都从头部插入，尽可能地从头部删除，同时规模接近最大。

# 03.cpp(测例同01.cpp)

## 最严重错误类型

最严重的错误类型是TLE。

## 出错原因

string的insert()和erase()最坏复杂度是O(string长度)，程序运行的最坏复杂度O(mn)约为10^12量级，因此会TLE。

## 测例构造思路

1. 初始序列达到最长

2. 尽可能地让insert()和erase()达到最坏，因此要尽可能多地在头部插入、头部消除

因此构造了这样一组测例，每次都从头部插入，尽可能地从头部删除，同时规模接近最大。

# 04.cpp

## 最严重错误类型

最严重的错误类型是WA。

## 出错原因

play函数中第13行处的--left会导致删除一段连续珠子时把前面的一颗异色珠子也删除，因此带来结果错误。

## 测例构造思路

构造一组测例使得删除连续三个珠子时前面存在一颗异色珠子即可。

# 05.cpp

## 最严重错误类型

最严重的错误类型是WA。

## 出错原因

读入时使用cin来获得a字符串，而cin如果只接受到一个换行符则会将其忽略并等待进一步输入，因此初始序列置空即可带来错误。

## 测例构造思路

初始序列为空，随便插入一颗珠子即可。

# 06.cpp

## 最严重错误类型

最严重错误类型是TLE。

## 出错原因

手动实现的块状链表无法自动平均分配各块的大小，因此可以向一个块中加入大量珠子使得它退化回朴素的vector，最坏复杂度仍然可以达到O(mn)。

## 测例构造思路

尽可能地只在第一个块中加入珠子，然后不断从头部插入、消除，以达到最坏复杂度。

# 07.cpp

## 最严重错误类型

最严重错误类型是RE。

## 出错原因

第227行赋值时没有判定head是否大于0，在checkLeft函数中如果找到最左侧，start为HEAD，则可能出现head为-1的情况，此时越界访问会引起RE。

## 测例构造思路

构造一组测例使得在checkLeft时找到最边缘即可。值得一提的是这个RE在GCC8.1.0上并未出现，题目所说的平台无关存疑。

# 08.cpp

## 最严重错误类型

最严重错误类型是WA。

## 出错原因

第230~235行将head指针挪动时，每次成功挪动后应将head置为-1而非0，否则遇到连续多个size为0的块时会出错。

## 测例构造思路

因为手工实现的块状链表无法动态调整大小，利用相消构造出两个size为0的块就会导致它出现错误。

# 09.cpp

## 最严重错误类型

最严重错误类型是WA。

## 出错原因

play函数中，当消除一次后，检查是否可以继续消除时将dis置为了1，而不是0.

## 测例构造思路

构造测例使得完成一次消除后出现两个同色珠子相邻即可。测试时发现这样在puts(a)时出现RE，因此需要再添加几个不同颜色的珠子，使得puts()不会RE。

# 10.cpp

## 最严重错误类型

最严重的错误类型是WA。

## 出错原因

在一个块的边缘消除时，r.second会达到一个块的边界，此时132行的r.second += 1会导致越界。

## 测例构造思路

构造一个包含两个块的测例，第一个块最右侧为BB，第二个块最左边是AAB，然后插入有一个A将第二个块最左边的AA消除，因为越界，第一个块最右边的BB无法看到第二个块最左边的B，导致三个同色珠子相连但没有消除的问题。
